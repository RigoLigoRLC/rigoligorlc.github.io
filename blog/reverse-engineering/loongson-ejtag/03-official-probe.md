
# 龙芯的官方 EJTAG 调试探头

# 硬件

龙芯 EJTAG 调试探头（下称 **“调试器”** ）采用了一片 Cypress CY7C68013A 单片机作为 USB HS PHY，并配置成 FIFO 模式，将 FIFO 的读写接口拉出供 FPGA 使用；FPGA 采用了一片 Altera Cyclone-II EP2C5T144，上面实现了对被调试芯片 TAP 的操纵逻辑。

FPGA 上面载有一个 MIPS789 软核，并配有 8KiB 的固件，以此实现 USB 通讯、指令包解析、TAP 控制逻辑等任务。

# USB 通信

## 描述符

调试器连接上电脑后是一个 Vendor Class 自定义设备，属于 USB 2.0 HS 设备，VID=0x2961（占了 Miselu 公司的位子），PID=0x6688 。

使用两个 USB 端点（Endpoint）进行 Bulk 传输：端点 2 为 OUT，端点 6 为 IN。

## 通信协议

上位机（`la_dbg_tool_usb`等程序，下同）与调试器遵守基本数据格式约定如下：

每次向调试器发送的字节流中含有一个或多个指令包。上位机会期待有的指令包被执行后，调试器向上位机回复一些回读的数据（否则上位机将无穷地等待下去，且协议中不存在超时重传、错误处理的部分）。一次发送了多个指令包时，调试器将顺序执行、按执行顺序返回数据。

包的一般结构如下：

|偏移量|长度|含义|
|-|-|-|
|[9:0]|10 位|每种指令特定的配置（下称 **“配置”**）|
|[15:10]|6 位|指令码|
|[...:16]|任意|负荷数据（可选）|

下面列出的指令码的定义来源于对 FPGA 固件、上位机程序的逆向工程与早年间旧版本 EJTAG 上位机中附带的部分头文件中发掘的信息。

理论上可以依据这些信息制作与官方的调试上位机相兼容的调试探头，但是需要注意的是，官方上位机存在使用 `usblooptest` 指令覆盖远古版本（准确地说是 2015 年的某个版本）固件中的代码的行为，这使得仅仅依据某个版本固件的逆向工程成果制作的兼容探头或许无法在将来使用。

注：下列定义来源于对一个固件版本为 `0x20210129` 的调试器的固件的逆向工程。使用了 Ghidra。部分内容同时参考了上位机程序的逆向工程。

- **0x01** 读写调试器内存空间（上位机指令：`usblooptest`，带有1个或者2个参数时）

  - 配置结构：

    |偏移量|长度|含义|
    |-|-|-|
    |[0:0]|1 位|此次操作为读（1）/写（0）|
    |[9:1]||不关心|

  - 负荷结构：

    |偏移量|长度|含义|
    |-|-|-|
    |[31:0]|4 字节|需要读/写的地址（调试器中的是一颗 32 位 MIPS-1 软核，故地址长度为32位）|
    |[63:32]|4 字节|（可选）写入的数值。|

  - 返回数据：

    |偏移量|长度|含义|
    |-|-|-|
    |[31:0]|4 字节|（可选）读的结果。如果此次操作是写，则不会返回任何数据。|

    PS. 调试器固件就是用这个指令 dump 出来的。而且，如果用 USB Blaster 连板上的 FPGA 的 JTAG 口，会发现是禁用的。
    
    PPS. 这个指令在手册里是用来修改 JTAG 时钟速度和采样点的，实际上是直接写 FPGA 内实现的 JTAG 逻辑电路的硬件寄存器。

- **0x03** 操作特定调试器 I/O 端口电平（上位机指令：`jtagled`）

    \* *此部分已经过硬件测量验证后重新修订。*

  - 配置结构：

    |偏移量|长度|含义|
    |-|-|-|
    |[0:0]|1 位|引脚电平高低|
    |[7:1]|7 位|引脚标号|
    |[8:9]||（不关心）|

    其中，引脚标号定义如下：

    |引脚标号|上位机指令中的名称|含义|
    |-|-|-|
    |0|led|调试器上的绿色 LED|
    |1|fpga_reset|（含义不明，FPGA 的 nCONFIG 引脚并未连接到 FPGA 自身可控制的器件上）|
    |2|oe|板上 74LVC573 触发器的 #OE 引脚|
    |3|trst|EJTAG 的 #TRST 信号|
    |4|brst|EJTAG 的 #BRST 信号|
    |5|dint|EJTAG 的 DINT 信号|
    |6|tap_reset|（含义不明，可能是用于清空 FPGA 内 TAP 控制器的内部信号？）|

  - 负荷结构：（无）
  - 返回数据：（无）

- **0x04** 读写 IR
  
  - 配置结构：

    |偏移量|长度|含义|
    |-|-|-|
    |[6:0]|7 位|JTAG 链上的 CPU 核心数|
    |[7:7]|1 位|不关心|
    |[8:8]|1 位|（如果此次操作为读操作，则）是否将读的结果发回上位机|
    |[9:9]|1 位|对 IR 的操作为写（1）/读（0）|

  - 负荷结构：

    |偏移量|长度|含义|
    |-|-|-|
    |[15:0]|2 字节|将要读/写 IR 数据的位数|
    |[...:16]|n * 4 字节|将要写入 IR 的数据；如仅需读取 IR 也需要放入占位数据。向上取整到 4 字节。|

  - 返回数据：

    |偏移量|长度|含义|
    |-|-|-|
    |[...:0]|n * 4 字节|（可选）读的结果。如果没有指定返回读取到的数据，则不会返回任何数据。向上取整到 4 字节。|

- **0x05** 读写 DR
  
  - 配置结构：

    |偏移量|长度|含义|
    |-|-|-|
    |[7:0]|8 位|JTAG链上的 CPU 核心数<br>注意：此处与 0x04 指令定义产生不同的主要原因是，上位机读写 IR 时额外按位与了`0x7f`起到了截取部分位的效果，在读写 DR 时没有写这个逻辑，因此我把除了另两个有意义的位以外的 8 位全部分配给了 CPU 核心数字段。|
    |[8:8]|1 位|（如果此次操作为读操作，则）是否将读的结果发回上位机|
    |[9:9]|1 位|对 IR 的操作为写（1）/读（0）|

  - 负荷结构：

    |偏移量|长度|含义|
    |-|-|-|
    |[15:0]|2 字节|将要读/写 DR 数据的位数|
    |[...:16]|n * 4 字节|将要写入 DR 的数据；如仅需读取 DR 也需要放入占位数据。向上取整到 4 字节。|

  - 返回数据：

    |偏移量|长度|含义|
    |-|-|-|
    |[...:0]|n * 4 字节|（可选）读的结果。如果没有指定返回读取到的数据，则不会返回任何数据。向上取整到 4 字节。|

- **0x08** 回环测试（上位机指令：`usblooptest`，不带有参数时）

  - 配置结构：（不关心）
  - 负荷结构：

    |偏移量|长度|含义|
    |-|-|-|
    |[31:0]|4 字节|上位机发来的一个随机数。|

  - 返回数据：

    |偏移量|长度|含义|
    |-|-|-|
    |[31:0]|4 字节|经过处理返回的随机数。|

    此处返回数据的处理方式为 **（未验证）**：
    ```c
    uint32_t ejtag_loopback_test(uint32_t input) {
        uint16_t input_lo = input & 0xFFFF;
        uint16_t input_hi = (input & 0xFFFF) >> 16;
        uint16_t ret_lo = (input_lo << (input_hi & 0x1F));
        uint16_t ret_hi = (input_lo >> (input_hi & 0x1F));
        return (ret_hi << 16) | ret_lo;
    }
    ```

- **0x0b** （不清楚）

  （等待整理）

- **0x0c** FASTWRITE（使用 FASTDATA）（包括 `put` 在内的许多种上位机指令均使用）
- **0x0d** FASTWRITE（不使用 FASTDATA）
  
  - 配置结构：

    |偏移量|长度|含义|
    |-|-|-|
    |[6:0]|7 位|JTAG 链上的 CPU 核心数。当此参数为 0 时，负荷结构中不存在描述目标 CPU 核的字段；否则，默认被调试设备上所有的物理 CPU 都有一个 TAP，且它们的 IR、DR 被首尾串联在一起、TDI 进入后首先到达 CPU0 。|
    |[7:7]|1 位|CPU 是否为 64 位|
    |[9:8]||（不关心）|

  - 负荷结构：

    |偏移量|长度|含义|
    |-|-|-|
    |[15:0]|2 字节|JTAG 时钟分频系数（设定下载速度用）。|
    |[47:16]|4 字节|写入数据字节数。向上取整到 4 字节。|
    |[63:48]|2 字节|（根据配置结构描述，可选）目标 CPU 核。|
    |[...]|n * 4 字节|将要写入的数据。|

  - 返回数据：（无）

    0x0c 与 0x0d 指令码均使用以上指令结构，只是根据调试器配置文件指定，选择是否使用 FASTDATA IR 指令以加快数据传输过程。

    上位机会先向 RAM 中上传一段机器码，让 CPU 跳转到那里执行。这段代码会从 dmseg 中读取数据然后写入到指定的目标地址，而这次访存操作的结果则将由 EJTAG TAP 提供，以此完成内存写操作。所以，此指令码的负荷中不包含写入的具体地址等信息。

- **0x0e** WR_UPLOAD（使用 FASTDATA）
- **0x0f** WR_UPLOAD（不使用 FASTDATA）

  （等待整理）

- **0x1f** 返回调试器固件版本  

  - 配置结构：（不关心）
  - 负荷结构：（无）
  - 返回数据：

    |偏移量|长度|含义|
    |-|-|-|
    |[31:0]|4 字节|BCD 编码的一个 YYYYMMDD 日期。|
