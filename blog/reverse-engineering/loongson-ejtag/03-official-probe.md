
# 龙芯的官方 EJTAG 调试探头

# 硬件

龙芯 EJTAG 调试探头（下称 **“调试器”** ）采用了一片 Cypress CY7C68013A 单片机作为 USB HS PHY，并配置成 FIFO 模式，将 FIFO 的读写接口拉出供 FPGA 使用；FPGA 采用了一片 Altera Cyclone-II EP2C5T144，上面实现了对被调试芯片 TAP 的操纵逻辑。

FPGA 上面载有一个 MIPS789 软核，并配有 8KiB 的固件，以此实现 USB 通讯、指令包解析、TAP 控制逻辑等任务。

# USB 通信

## 描述符

调试器连接上电脑后是一个 Vendor Class 自定义设备，属于 USB 2.0 HS 设备，VID=0x2961（占了 Miselu 公司的位子），PID=0x6688 。

使用两个 USB 端点（Endpoint）进行 Bulk 传输：端点 2 为 OUT，端点 6 为 IN。

## 通信协议

上位机（`la_dbg_tool_usb`等程序，下同）与调试器遵守基本数据格式约定如下：

每次向调试器发送的字节流中含有一个或多个指令包。上位机会期待有的指令包被执行后，调试器向上位机回复一些回读的数据（否则上位机将无穷地等待下去，且协议中不存在超时重传、错误处理的部分）。一次发送了多个指令包时，调试器将顺序执行、按执行顺序返回数据。

包的一般结构如下：

|偏移量|长度|含义|
|-|-|-|
|[9:0]|10 位|每种指令特定的配置（下称 **“配置”**）|
|[15:10]|6 位|指令码|
|[...:16]|任意|负荷数据（可选）|

下面列出的指令码的定义来源于对 FPGA 固件、上位机程序的逆向工程与早年间旧版本 EJTAG 上位机中附带的部分头文件中发掘的信息。

注：下列定义来源于对一个固件版本为 `0x20210129` 的调试器的固件的逆向工程。使用了 Ghidra。

- **0x01** 读写调试器内存空间（上位机指令：`usblooptest`，带有1个或者2个参数时）

  - 配置结构：

    |偏移量|长度|含义|
    |-|-|-|
    |[0:0]|1 位|此次操作为读（1）/写（0）|
    |[9:1]||不关心|

  - 负荷结构：

    |偏移量|长度|含义|
    |-|-|-|
    |[31:0]|4 字节|需要读/写的地址（调试器中的是一颗 32 位 MIPS-1 软核，故地址长度为32位）|
    |[63:32]|4 字节|（可选）写入的数值。|

  - 返回数据：

    |偏移量|长度|含义|
    |-|-|-|
    |[31:0]|4 字节|（可选）读的结果。如果此次操作是写，则不会返回任何数据。|

    PS. 调试器固件就是用这个指令 dump 出来的。而且，如果用 USB Blaster 连板上的 FPGA 的 JTAG 口，会发现是禁用的。
    
    PPS. 这个指令在手册里是用来修改 JTAG 时钟速度和采样点的，实际上是直接写 FPGA 内实现的 JTAG 逻辑电路的硬件寄存器。

- **0x03** 操作特定调试器 I/O 端口电平（上位机指令：`jtagled`）

    **注意：此指令逆向的结果来自上位机逆向工程，且没有经过详尽测试验证，行为均为推测；下位机固件逆向得比较糊涂，因此不保证行为正确**
  - 配置结构：

    |偏移量|长度|含义|
    |-|-|-|
    |[0:0]||板上绿色 LED|
    |[1:1]||（上位机程序称此信号为 `fpga_reset` ，但似乎没有电气连接？）|
    |[2:2]||板上 74LVC573 触发器的 `#OE` 信号|
    |[3:3]||#TRST 信号|
    |[4:4]||BRST 信号|
    |[5:5]||DINT 信号|
    |[6:6]||（上位机程序称此信号为 `tap_reset`，但疑似与[3:3]重复，无法判断）|
    |[7:9]||（不关心）|

  - 负荷结构：（无）
  - 返回数据：（无）

- **0x04** 读写 IR
  
  - 配置结构：

    |偏移量|长度|含义|
    |-|-|-|
    |[6:0]|7 位|JTAG链上的 CPU 核心数|
    |[7:7]|1 位|不关心|
    |[8:8]|1 位|（如果此次操作为读操作，则）是否将读的结果发回上位机|
    |[9:9]|1 位|对 IR 的操作为写（1）/读（0）|

  - 负荷结构：

    |偏移量|长度|含义|
    |-|-|-|
    |[15:0]|2 字节|将要读/写 IR 数据的位数|
    |[...:16]|n * 4 字节|将要写入 IR 的数据；如仅需读取 IR 也需要放入占位数据。向上取整到 4 字节。|

  - 返回数据：

    |偏移量|长度|含义|
    |-|-|-|
    |[...:0]|n * 4 字节|（可选）读的结果。如果没有指定返回读取到的数据，则不会返回任何数据。向上取整到 4 字节。|

- **0x05** 读写 DR
  
  - 配置结构：

    |偏移量|长度|含义|
    |-|-|-|
    |[7:0]|8 位|JTAG链上的 CPU 核心数<br>注意：此处与 0x04 指令定义产生不同的主要原因是，上位机读写 IR 时额外按位与了`0x7f`起到了截取部分位的效果，在读写 DR 时没有写这个逻辑，因此我把除了另两个有意义的位以外的 8 位全部分配给了 CPU 核心数字段。|
    |[8:8]|1 位|（如果此次操作为读操作，则）是否将读的结果发回上位机|
    |[9:9]|1 位|对 IR 的操作为写（1）/读（0）|

  - 负荷结构：

    |偏移量|长度|含义|
    |-|-|-|
    |[15:0]|2 字节|将要读/写 DR 数据的位数|
    |[...:16]|n * 4 字节|将要写入 DR 的数据；如仅需读取 DR 也需要放入占位数据。向上取整到 4 字节。|

  - 返回数据：

    |偏移量|长度|含义|
    |-|-|-|
    |[...:0]|n * 4 字节|（可选）读的结果。如果没有指定返回读取到的数据，则不会返回任何数据。向上取整到 4 字节。|

- **0x08** 回环测试（上位机指令：`usblooptest`，不带有参数时）

  - 配置结构：（不关心）
  - 负荷结构：

    |偏移量|长度|含义|
    |-|-|-|
    |[31:0]|4 字节|上位机发来的一个随机数。|

  - 返回数据：

    |偏移量|长度|含义|
    |-|-|-|
    |[31:0]|4 字节|经过处理返回的随机数。|

    此处返回数据的处理方式为 **（未验证）**：
    ```c
    uint32_t ejtag_loopback_test(uint32_t input) {
        uint16_t input_lo = input & 0xFFFF;
        uint16_t input_hi = (input & 0xFFFF) >> 16;
        uint16_t ret_lo = (input_lo << (input_hi & 0x1F));
        uint16_t ret_hi = (input_lo >> (input_hi & 0x1F));
        return (ret_hi << 16) | ret_lo;
    }
    ```

- **0x0b** （不清楚）

  （等待整理）

- **0x0c** FASTWRITE（使用 FASTDATA）

  （等待整理）

- **0x0d** FASTWRITE（不使用 FASTDATA）

  （等待整理）

- **0x0e** WR_UPLOAD（使用 FASTDATA）

  （等待整理）

- **0x0f** WR_UPLOAD（不使用 FASTDATA）

  （等待整理）

- **0x1f** 返回调试器固件版本  

  - 配置结构：（不关心）
  - 负荷结构：（无）
  - 返回数据：
  
    |偏移量|长度|含义|
    |-|-|-|
    |[31:0]|4 字节|BCD 编码的一个 YYYYMMDD 日期。|
