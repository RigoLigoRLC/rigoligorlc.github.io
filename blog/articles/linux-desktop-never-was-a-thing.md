
# Linux Desktop Never Was A Thing

> _Windows是少数天才程序员和很多笨蛋程序员一起开发的一个操作系统。Linux是少数天才程序员和很多自认为天才的傻逼程序员表面上合作但其实各自开发的一堆操作系统。——知乎用户@柳叶擦眼_

不论在阅读本文的您是否曾因为工作需要、开发需求、旧电脑反应慢被“高人指点”、不满于闭源操作系统的封闭性/AI Slop/Bug百出等问题使用过Linux桌面，也不论您是否收获了优秀、堪用或是完全无法容忍的使用体验，本文都一视同仁地向您表达如下的观点：

笔者不是说某款Linux桌面系统是垃圾，笔者是说在场的所有Linux桌面系统都是垃圾；

在当前的技术与治理环境下，Linux桌面社区的几轮“Linux桌面元年”hype等“崛起”言论终究都是一厢情愿，甚至可以说是黄梁一梦。

当然，许多技术人一听到笔者这样发表暴论就要马上抄起键盘来开始反驳了。先别急！您身为技术人，更应该相比“麻瓜”们更了解这个平台一些。如果您自己都不知道这个平台的局限性何在，就更无法同笔者这样的神圣切割战士作斗争、为Linux桌面争气了。

## 0. Scope

笔者将要讨论的范围仅限于“通用Linux桌面操作系统”。

通用 - 某一基于Linux的操作系统应当不是为了特定用途和硬件设计、而展现出对此特定领域外用户的排斥：这是为了排除Kali Linux（几乎专为渗透测试服务）、Steam OS（与Steam硬件绑定）、各国政府使用的基于Linux的操作系统（绑定国家安全领域）、ChromeOS（使用Android Kernel且基本只以Chrome为用户界面）等操作系统；

桌面 - 专指基于FreeDesktop体系的、具有图形化用户界面的操作系统：这是为了排除Android、OpenHarmony这类拥有专属的应用软件和图形化界面生态的操作系统。

请注意：虽然上面两个条件排除了一部分操作系统，但这并不代表本文以下的所有论调对它们均不适用。同时，您可能已经注意到，笔者非常关注“麻瓜”使用Linux桌面系统的视角。为了与闭源的竞争者抗衡，争取普通用户的留存是必要的，这也是本文的基本立场之一。（操作系统一定要有用户用🙌😭🙌😭🙌😭🙌）

## 1. Das Components

笔者在与Linux桌面打交道的过程中，逐渐开始认为Linux桌面系统具有系统性的问题：每个软件组件，或多或少都不是很适应桌面操作系统的形态。当然，除了软件组件技术性质本身以外还有其他的问题，笔者会在下面的章节单独展开。

### 1.1 Kernel

谈到Linux Kernel，大家也都比较喜闻乐见。作为一个有着非常成功的商业模式的个人开源项目，它自然和Windows、macOS这类商业闭源操作系统的内核有着不同的工作方式。而使用Linux桌面系统遇到的头号老大难问题就是Kernel干的好事带来的：硬件支持。

谈起硬件支持，很多人会想起Linus的“So NVIDIA, fsck you”；这固然反映了硬件公司对Linux桌面系统支持态度的一角，但如果反过来思考，Linux对开源的内核组件的支持真的有多么优秀吗？

许多技术朋友们对Linux Kernel的策略并不陌生：Kernel只维护系统调用API/ABI稳定性，而不维护内核内部API/ABI的稳定性；前者的理由是为了维护用户态软件的兼容性，后者的理由则是为了防止内核内的实现细节的稳定性阻碍内核本身的演进。对于开源社区的开发者来说这很有道理：内核怎么工作是我们做内核态的开发者内部的事情，真正需要的是对用户态的用户和应用负责；可惜的是硬件供应商往往并不（或者说，不能）按照开源软件社区的方式行事（而这一点在GPU这种异构加速器硬件上更是被进一步放大）：

在那个“计算机公司卖硬件，软件公司写系统软件”的小型机年代，操作系统厂商自己写硬件驱动程序不是什么奇怪的事情，往往一款操作系统也绑定某个特定的计算机型号——Unix通过使用C语言实现可移植性甚至都是个亮点。但到了PC（个人电脑）普及的年月，市场上出现无数种可用的外设，操作系统厂商想要再自己包揽所有的硬件驱动程序就不现实了。Windows经历了从MS-DOS 2.0、到Windows 3.0/95（VxD）、到Windows 98一步步的重构，终于建设起了沿用至今的WDM（Windows Driver Model）框架；在WDM驱动框架下，一切设备对象都是一颗统一的树上的节点，树的根由ACPI开始构建，随后一层层向上枚举并发现所有能够加载驱动程序的设备对象；每个设备对象与其父子节点之间具有统一的调用接口（IRP，I/O Request Packet），部分接口上还可以设置过滤驱动程序供安全应用或调试使用。

私以为Windows的I/O子系统是操作系统硬件支持能力的巅峰之作：在历史发展和商业需求驱动下演进出了极高的灵活性，而高度统一的接口又同时保证了API和ABI两个层面上的兼容性。这当然带来了一些问题，比如抽象复杂导致一定的性能下降；但我认为这更多是一个工程上的妥协：这是为高度不受控的最终硬件环境不得不作出的让步。

Linux Kernel的开发思路技术上并不算错，但要求硬件厂商一定要将其设备驱动提交给上游、进入上游维护显然是一个理想化的场景：厂商不一定想要让其他人了解其硬件的实现细节，或者免费将公司的软件研发成果“拱手让人”；厂商的软件迭代节奏不一定能支持Linux Kernel的“集市”式开发的沟通模式、补丁被反复打回修改的开发节奏（企业通常不会喜欢产品开发周期不确定带来的风险）。

如果厂商不想这样做，那就要么放弃Linux支持，要么单独提供为某个特定Linux版本构建内核模块的源码，而后者通常缺乏维护，内核的小版本更新就能直接破坏掉它们；即使厂商提供了源码并且针对新内核版本不断进行维护，用户仍然需要在内核进行任何更新时在自己的机器上重新构建内核模块，直到DKMS出现前用户甚至需要手动维护。

但是即使是在开源社区，也有与NVIDIA一样的受害者经常被笔者拿出来举例：它就是大名鼎鼎的ZFS驱动。因为许可证问题，ZFS驱动无法进入Linux Kernel代码树，因而一直作为树外模块存在。但由于ZFS优秀的特性，又有许多用户不得不在Linux中使用ZFS，而将文件系统这样重要的组件也置于不稳定的KAPI之下导致的直接后果就是用户要承担高得多的“更新内核导致系统原地瘫痪”的风险。而这甚至不是“麻瓜”，而是广大技术人员都头疼的风险，“把ZFS驱动像NVIDIA驱动当祖宗一样‘供起来’”也成了很多人的无奈之举。

近年来，也有一些硬件厂商加入了Linux Kernel开发者的行列，为Linux添加自家硬件的支持，但这没有从根本上彻底改变Linux桌面系统硬件支持糟糕的现状。由于各类原因下Linux桌面系统目前的市场占有率本就不高，硬件厂商开发的主要驱动力首先来源于服务器、数据中心级硬件甚至是嵌入式Linux的支持：由于互联网、大数据乃至近期的AI热潮影响，支持这些硬件可以让厂商多卖很多很贵的硬件，而桌面级硬件不能；再者，需要支持的硬件并不只有CPU和GPU，还有无数种外设芯片（例如网卡和声卡）、对特定平台的支持（例如特定型号的笔记本电脑），而这些硬件的厂商相比Intel、AMD、NVIDIA“不支持就要亏很多服务器芯片钱”又没有什么去做Linux支持的动力，结果Linux桌面系统对笔记本电脑这种非常需要垂直整合能力的计算机的支持就自然而然地劣化起来。

硬件的部分至此结束，接下来是属于软件栈的混沌地狱。

Linux Kernel源于Linus从Minix汲取灵感的重写，而Linux这样的类Unix系统自然而然地秉持着类Unix系统祖传的惯例：系统调用接口是需要向用户保证的稳定接口。

乍一看，内核开发者维护系统调用接口这个用户态与内核态的边界不就是天经地义的吗？

然而，2026年的应用程序早已和Unix诞生的20世纪70年代，用户态运行时的复杂度早已不同当年，甚至让内核开发者不能再把自己的头埋在“系统调用接口稳定”这层沙子下面。恰恰由于整个操作系统的开发思维认为内核提供的接口是用户态的黄金标准，导致了libc及其上的ABI兼容性完全乱套的后果……

## 1.2 libc

除非您的Linux系统整个用户态都由Go这类不依赖于系统C运行时的语言编写，那么libc就是永远绕不开的话题。而开发者和用户无不从这一层开始遭受着无休止的折磨。


